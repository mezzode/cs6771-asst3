template <typename N, typename E>
bool Graph<N, E>::addNode(const N& val) {
    if (isNode(val)) {
        return false;
    }
    nodes[val] = std::make_shared<Node>(val);
    return true;
}

template <typename N, typename E>
bool Graph<N, E>::addEdge(const N& src, const N& dst, const E& w) {
    shared_ptr<Node> s = nodes[src];
    shared_ptr<Node> d = nodes[dst];
    shared_ptr<Edge> e = std::make_shared<Edge>(s, d, w);
    *s.edges.insert(e);
    *d.edges.insert(e);
}

template <typename N, typename E>
bool Graph<N, E>::replace(const N& oldData, const N& newData) {
    if (!isNode(oldData)) {
        throw std::runtime_error();
    }
    if (isNode(newData)) {
        return false;
    }

    shared_ptr<Node> n = nodes[oldData];
    nodes[newData] = n;
    *n.val = newData;
    nodes.erase(oldData);
    return true;
}

template <typename N, typename E>
void Graph<N, E>::mergeReplace(const N& oldData, const N& newData) {
    if (!isNode(oldData) || !isNode(newData)) {
        throw std::runtime_error();
    }

    shared_ptr<Node> newNode = nodes[newData];
    shared_ptr<Node> oldNode = nodes[oldData];
    nodes.erase(oldData);
    // at this point, oldNode should be the only shared_ptr to that node
    for (auto edge : oldNode->inEdges) {
        edge->dst = newNode;
        newNode->inEdges.insert(edge);
    }
    for (auto edge : oldNode->outEdges) {
        edge->src = newNode;
        newNode->outEdges.insert(edge);
    }

    // remove duplicates i.e. same src, dest and weight
    std::set<std::pair<E, weak_ptr<Node>>> seen;
    for (auto it = std::begin(newNode->inEdges); it != std::end(newNode->inEdges); ++it) {
        auto result = seen.insert(std::make_pair(it->w, it->src)); // (*it)->w is the proper thingo but may be unnecessary since -> chaining?
        if (!result.second) {
            // already seen, thus is duplicate so delete
            it = newNode->inEdges.erase(it);
        }
    }
    seen.clear();
    for (auto it = std::begin(newNode->outEdges); it != std::end(newNode->outEdges); ++it) {
        auto result = seen.insert(std::make_pair(it->w, it->src)); // (*it)->w is the proper thingo but may be unnecessary since -> chaining?
        if (!result.second) {
            // already seen, thus is duplicate so delete
            it = newNode->outEdges.erase(it);
        }
    }
}

template <typename N, typename E>
void Graph<N, E>::deleteNode(const N& n) noexcept {
    if (!isNode(n)) {
        return;
    }
    shared_ptr<Node> node = nodes[n];
    for (auto edge : node->inEdges) {
        deleteEdge(edge->src->val, edge->dst->val, edge->w);
    }
    for (auto edge : node->outEdges) {
        // node->val should be same as edge->src->val
        deleteEdge(edge->src->val, edge->dst->val, edge->w);
    }
    nodes.erase(n);
}

template <typename N, typename E>
void Graph<N, E>::deleteEdge(const N& src, const N& dst, const E& w) noexcept {
    // first check if correctly identifies an edge
    if (!isNode(src) || !isNode(dst)) {
        return;
    }
    shared_ptr<Edge> edge = nodes[src].getEdgeTo(dst, w);
    if (edge == nullptr) {
        // edge does not exist
        return;
    }

    // remove edge from src and dst nodes
    nodes[src]->outEdges.erase(edge);
    nodes[dst]->inEdges.erase(edge);
}

template <typename N, typename E>
void Graph<N, E>::clear() noexcept {
    nodes.clear();
}

template <typename N, typename E>
bool Graph<N, E>::isNode(const N& val) const {
    return nodes.count(val) > 0;
}

template <typename N, typename E>
bool Graph<N, E>::isConnected(const N& src, const N& dst) const {
    if (!isNode(src) || !isNode(dst)) {
        throw std::runtime_error();
    }
    return nodes[src]->isConnected(dst);
}

template <typename N, typename E>
void Graph<N, E>::printNodes() const {
    std::vector<shared_ptr<Node>> tmp;
    for (auto& kv : nodes) {
        tmp.push_back(kv.second);
    }
    std::sort(std::begin(tmp), std::end(tmp),
        [](const shared_ptr<Node>& a, const shared_ptr<Node>& b) -> bool {
            if (a->outdegree() != b->outdegree()) {
                return a->outdegree() < b->outdegree();
            }
            return a->val < b->val;
        }
    );
    for (shared_ptr<Node> node : tmp) {
        std::cout << node->val << std::endl;
    }
}

template <typename N, typename E>
void Graph<N, E>::printEdges(const N& val) const {
    if (!isNode(val)) {
        throw std::runtime_error();
    }
    shared_ptr<Node> node = nodes[val];
    std::cout << "Edges attached to Node " << node->val << std::endl;
    if (node->outdegree() == 0) {
        std::cout << "(null)" << std::endl;
        return;
    }
    std::vector<shared_ptr<Edge>> tmp;
    for (auto& edge : node->outEdges) {
        tmp.push_back(edge);
    }
    std::sort(std::begin(tmp), std::end(tmp),
        [](const shared_ptr<Edge>& a, const shared_ptr<Edge>& b) -> bool {
            if (a->w != b->w) {
                return a->w < b->w;
            }
            return a->dst->val < b->dst->val;
        }
    );
    for (shared_ptr<Edge> edge : tmp) {
        std::cout << edge->dst->val << edge->w << std::endl;
    }
}

template <typename N, typename E>
void Graph<N, E>::begin() const {
    it = nodes.begin();
}

template <typename N, typename E>
bool Graph<N, E>::end() const {
    return it == nodes.end();
}

template <typename N, typename E>
void Graph<N, E>::next() const {
    ++it;
}

template <typename N, typename E>
const N& Graph<N, E>::value() const {
    return *it;
}